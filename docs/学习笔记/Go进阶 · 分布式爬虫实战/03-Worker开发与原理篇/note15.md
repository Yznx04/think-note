# 15-众人拾柴：高效团队的Go编码规范

## 我们为什么需要编程规范

编程规范又叫代码规范，是团队在代码开发时需要遵守的约定。好处有：

- 促进团队合作
- 规避错误
- 提升性能
- 便于维护

什么是好代码？整洁、一致的，健壮、可扩展的。 那么规范的目的就应该是达到团队产出好代码。

## 整洁、一致

这是好代码的第一个要求，代码的整洁包括格式化、命名、函数等细节。

**格式化**

1. 代码长度
    - [强制 lll] 一行不超过120个字符，同时避免刻意断行。某一行太长了，需要改名或调整语义。
    - [强制 funlen] 单个函数行数不超过40行，过长的函数表示函数功能不专一、定义不明确、程序结构不合理，不易与理解
    - [强制] 单个文件不超过2000行，过长说明定义不明确，程序结构划分不合理，不利于维护。

2. 代码布局
    - [建议]Go文件推荐按照以下顺序布局，每个部分之间用一个空行分割。每个部分有多个类型定义或者有多个函数时，也用一个空行分割。
        1. 包注释：对整个模块和功能进行描述，写在文件头部
        2. Package：包名称
        3. Imports：引入的包
        4. Constants：常量定义
        5. Typedefs：类型定义
        6. Globals：全局变量定义
        7. Functions：函数实现
    - [强制 goimports] 当import多个包时，应该对包进行分组。同一组的包之间不需要有空行，不同组之间需要有空行。标准库的包应该放在第一组。

3. 空格与缩进
    - [强制 gofmt] 注释和声明应该对齐
    - [强制 gofmt] 小括号、中括号、大括号内侧都不加空格
    - [强制 gofmt] 逗号、冒号(slice中的冒号除外)前都不加空格，后面加1个空格
    - [强制 gofmt] 所有二元运算符前后各加一个空格，作为函数参数时除外
    - [强制 gofmt] 使用Tab而不是空格进行缩进
    - [强制 nlreturn] return前面需要加一个空行，让代码逻辑更清晰
    - [强制 gofmt] 判断语句、for循环语句需要缩进一个Tab，并且右大括号与对应的if关键词垂直对齐。
    - [强制 goimports] 当 import 多个包时，应该对包进行分组。同一组的包之间不需要有空行，不同组之间的包需要一个空行。标准库的包应该放在第一组。这同样适用于常量、变量和类型声明：
    - [建议]避免else语句中处理错误返回，避免正常的逻辑位于缩进当中
    - [建议]函数内不同的业务逻辑处理建议用单个空行分割
    - [建议]注释之前的空行有助于提高可读性,新注释的注[建议]入代表新思想的开始

**命名**

一个好的命名应该满足以下条件：

- 短，易于拼写
- 保持一致性
- 意思准确，易于理解，没有虚假和无意义的信息

[强制 revive] Go中的命名方式统一使用驼峰式、不要加下划线

[强制 revive] 缩写的专有名词应该大写，例如：HTTPServer

[强制] 区分变量名必须是有意义的名字，而不是使用阿拉伯数字

[强制] 不要在变量名称中包含你的类型名称

[建议]变量的作用域越大，变量名应该越长

**包名**

包名应该简短而清晰。

[强制] 使用简短的小写字母，不需要下划线或者混合大写字母

[建议] 合理使用缩写

[强制] 避免无意义的报名，例如：util、common、base

**接口命名**

[建议] 单方法接口由方法名+er后缀或类似修饰来命名。例如：Reader; 当一个接口包含多个方法时，选择一个能够准确描述其用途的名称

**本地变量命名**

[建议] 尽可能断。在这里，i代替index，r代表reader， b代表buffer

**函数参数命名**

[建议] 如果函数参数的类型已经可以看出参数的含义，那么函数参数的命名就应该尽可能简短

[建议] 如果函数的参数类型不能看出参数的含义，那么函数参数的命名就应该尽量精确

**函数返回值命名**

[建议] 对于公开的函数，返回值具有文档意义，应该准确表达含义。

**可导出的变量名**

[建议] 由于可导出的变量名在使用时会加上包名，因此，不需要对变量重复命名。例如bytes包中的ByteBuffer替换为Buffer, 这样就是
bytes.Buffer。

**Error值命名**

[建议] 错误类型应该以Error结尾

[建议] Error变量应该以Err开头

**函数**

[强制 cyclop] 圈复杂度（Cyclomatic complexity）小于10

[强制 gochecknoinits] 避免使用init函数

[强制 revive] Context应该作为函数的第一个参数

[强制] 正常情况下禁用unsafe

[强制] 禁止return裸返回

[强制] 不要在循环中使用defer，除非你真的清楚defer的工作流程。

[强制] 通过`:=`进行变量赋值的场景，禁止出现仅部分变量初始化的情况。最常见的就是初始化前面声明过的err

[建议] 函数返回值大于3个时，建议通过struct封装

**控制结构**

[强制] 禁止使用goto

[强制 gosimple] 当一个表达式为bool类型时，应该使用expr或!expr判断，禁止使用==或!=来与true/false进行比较

[强制 nestif] if嵌套深度不大于5

**方法**

[强制] receiver的命名要保持一致，在一个方法中命名为C，那么其他方法中就不能命名为cl

[强制] receiver的命名要尽量简短并有意义，禁止为this、self

**注释**

Go提供C语言风格的注释。有//行注释和/**/块注释两种。注释的作用：

1. 提供具体的逻辑细节和代码背后的意图和决策;
2. 帮助澄清一些晦涩的参数和返回值的含义;
3. 强调某一个重要的功能

好的注释需要满足：what、how、why，方便后续的代码维护。

[强制] 无用注释直接删除，无用代码也是直接删除而不是通过注释说明

[强制] 紧跟在代码之后的注释，使用//

[强制] 统一使用中文注释，中英文字符之间严格使用空格分割

[强制] 注释不需要额外的格式，例如星号横幅

[强制] 包、函数、方法和类型的描述都是一个完整的句子，以被描述的对象为主语开头

[强制] Go语言提供了文档注释工具go doc，可以生成注释导出函数的文档。

[强制 godot] 注释最后应该以句号结尾

[建议] 当某个部分等待完成时，可以使用TODO:开头的注释来提醒维护人员

[建议] 大部分情况下使用行注释。块注释主要用在包的注释上，不过块注释在表达式中或禁用大量代码时很有用。

[建议] 当某个部分存在已知问题需要修复或改进时，可用 FIXME: 开头的注释来提醒维护人员。

[建议] 需要特别说明某个问题时，可用 NOTE: 开头的注释。

**结构体**

[强制] 不要将 Context 成员添加到 Struct 类型中。

## 高效

[强制] Map在初始化时需要指定长度make(map[T1]T2, hint)。

[强制] Slice在初始化时需要指定长度和容量make([]T, length, capacity)。

[强制] time.After()在某些情况下会发生泄露，替换为使用Timer。

[强制] 数字与字符串转换时，使用strconv，而不是fmt。

[强制] 读写磁盘时，使用读写buffer。

[建议] 谨慎使用Slice的截断操作和append操作

[建议] 任何书写的协程，都需要明确协程什么时候退出。

[建议] 热点代码中，内存分配复用内存可以使用 sync.Pool 提速。

[建议] 将频繁的字符串拼接操作（+=），替换为StringBuffer 或 StringBuilder。

[建议] 使用正则表达式重复匹配时，利用Compile提前编译提速。

[建议] 当程序严重依赖Map时，Map的Key使用int而不是string将提速。

[建议] 多读少写的场景，使用读写锁而不是写锁将提速。

## 健壮性

[强制] 除非出现不可恢复的程序错误，否则不要使用 panic 来处理常规错误，使用 error 和多返回值。

[强制 revive] 错误信息不应该首字母大写（除专有名词和缩写词外），也不应该以标点符号结束。因为错误信息通常在其他上下文中被打印。

[强制 errcheck] 不要使用 _ 变量来丢弃 error。如果函数返回 error，应该强制检查。

[建议] 在处理错误时，如果我们逐层返回相同的错误，那么在最后日志打印时，我们并不知道代码中间的执行路径。因此，在中间处理err时，需要使用fmt.Errorf
或第三方包给错误添加额外的上下文信息。

[强制] 利用recover捕获panic时，需要由defer函数直接调用。

[强制] 不用重复使用recover，只需要在每一个协程的最上层函数拦截即可。recover只能够捕获当前协程，而不能跨协程捕获panic。

[强制] 有些特殊的错误是recover不住的，例如Map的并发读写冲突。这种错误可以通过race工具来检查。

## 扩展性

[建议] 利用接口实现扩展性。

[建议] 使用功能选项模式对一些公共API的构造函数进行扩展，大量第三方库例如gomicro、zap等都使用了这种策略。

## 工具

**golangci-lint**

golangci-lint 是当前大多数公司采用的静态代码分析工具，词语Linter 指的是一种分析源代码以此标记编程错误、代码缺陷、风格错误的工具。
golangci-lint 是集合多种Linter的工具。

Go语言实现来Linter的API，还提供了golint工具，用于集成来了几种常见的工具。Linter的实现原理是静态扫描代码的AST。
golangci-lint里面其实已经集成了包括golint在内的总多Linter，并且有灵活的配置能力。所以在自己写Linter之前，建议先了解golangci-lint现有的能力。

**Pre-Commit**

在代码通过Git Commit提交到代码仓库之前，git 提供了一种pre-commit的hook能力，用于执行一些前置脚本。
在脚本中加入检查的代码，就可以在本地拦截住一些不符合规范的代码，避免频繁触发CI或者浪费时间。

**并发检测 race**

Go 1.1 提供了强大的检查工具race来排查数据争用问题。race 可以用在多个Go指令中，一旦检测器在程序中找到数据争用，就会打印报告。
这份报告包含发生race冲突的协程栈，以及此时正在运行的协程栈。可以在编译时和运行时执行race

**覆盖率**

一般我们会使用代码覆盖率来判断代码书写的质量，识别无效代码。go tool cover 是go语言提供的识别代码覆盖率的工具。

