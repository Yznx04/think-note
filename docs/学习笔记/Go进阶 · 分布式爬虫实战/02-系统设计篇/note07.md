# 07|深入Go高并发网络模型

## 阻塞与非阻塞

程序在运行过程中，要么是在执行，要么是等待执行（陷入阻塞状态）。常见的两种任务模式：

- CPU密集型：程序的处理时间大多花在CPU上，那就是CPU-Bound系统
- I/O密集型：程序的大多数时间花费在等待I/O上，那就是I/O-Bound系统

很多网络服务都属于I/O密集型系统，因为把大量时间花在了网络请求上。一个高效的网络服务需要能够处理以下问题：

- 一个任务的阻塞不能影响其他任务的执行
- 任务之间能够并行
- 当阻塞的任务准备好之后，能够恢复运行

## 文件描述符与Socket

网络编程避不开Socket,Socket大多数时候指向的是一个“插槽”。在建立网络连接时，需要建立一个Socket，客户端和服务端要想发送和接收数据都需要经过Socket。
在linux一切皆文件的设计下，Socket是一个特殊的文件，存储在描述进程的task_struct结构中。  

在另一些时候，Socket指的是用户态和内核态之间进行交换的API。现代操作系统在处理网络协议栈时，链路层Ethernet协议，网络层IP协议、传输层TCP协议都是在
操作系统内核实现的。而应用层是在用户态由应用程序实现的。应用程序和操作系统之间交流的接口就是通过操作系统提供的Socket系统调用API完成的。

还有些时候，Socket可以指Socket API中的socket函数。

## I/O模型

I/O模型被分为五种：

- 阻塞I/O：最简单直接的类型，会阻塞到操作完成。
- 非阻塞I/O：不会陷入阻塞，一般通过Socket指定为`SOCK_NONBLOCK`非阻塞模式来实现。不会阻塞，但是会一直返回具体的错误。所以，这种方式需要开发者采用轮询的方式进行查询。
- 多路复用I/O：依然可以阻塞，但是，可以一次监听多个Socket是否准备就绪，任何一个Socket准备就绪就会返回。典型的函数有pool、select、epoll.
- 信号驱动I/O：相对异步的一种方式，当Socket准备就绪后，通过中断、回调机制来通知调用后续对应的I/O操作，而后续的操作一般是阻塞的。
- 异步I/O：异步化更加彻底，全程无阻塞，调用者可以继续处理后续的流程。所有的操作都完全托管给操作系统。当I/O操作完全处理完毕后，操作系统会通过中断、回调等机制通知调用者。

现实中，最常用的模型是阻塞I/O模型和多路复用模型。

根据不同的I/O模型，不同线程与进程的组织方式，产生了许多不同的网络模型。最知名的是**Reactor**网络模型。Reactor网络模型可以理解为：
**I/O多路复用+线程池的解决方案**。目前Linux平台上大多数知名的高性能网络库和框架都使用来Reactor网络模型，包括：Redis、Nginx、Netty、Libevent等等。

Reactor本身有反应堆的意思，表示对监听的事件做出相应的反应。Reactor网络模型的思想是监听事件的变化，一般是通过I/O多轮复用监听多个Socket状态的变化，并
将对应的事件分发到对应的线程中去处理。

Reactor网络模型有很多的变种，包括：

- 单Reactor单进程/多进程
- 单Reactor多进程
- 多Reactor多进程/线程

多进程Reactor的流程：主Reactor使用select等多路复用机制监控连接建立事件，收到后事件通过Acceptor接受，并将新的连接分配给子Reactor。
随后，子Reactor会将主Reactor分配的连接加入连接队列，监听Socket的变化，当Socket准备就绪后，在独立的进程中完成完整的业务流程。

## 基于协程的网络处理模型

Go采用了一种非传统的方式来构建自己的网络模型，可以简单理解为：**I/O多路复用+非阻塞I/O+协程**。协程是基于线程的轻量级实现，降低了线程的时间成本和空间成本。

线程的时间成本主要来自切换线程上下文时，用户态和内核态的切换、线程的调度、寄存器变量以及状态信息的存储。

线程的空间成本主要来自于线程的堆栈大小。线程的堆栈大小一般是创建的时候指定的，为了避免栈溢出（Stack Overflow）。默认的栈大小为2MB。


## 同步编程模式

Go采用的是阻塞式编程，但是，阻塞的协程，不是进程，一个协程阻塞了，但是不会阻塞进程。Go通过调度其他协程，到线程上执行。

## 多路复用

Go网络模型中的另一个重要特点是多路复用。当协程阻塞时，有机制可以监听大量的socket的变化。当socket准备就绪后，能够让被阻塞的协程恢复执行。

Go实现了对不同操作系统提供的多路复用api(epoll、kqueue、iocp)的封装。将这种机制称为netpoll。

在Linux中，netpoll封装的是epoll。epoll中提供了三个API, epoll_create用于初始化epoll实例, epoll_ctl将需要监听的socket放入epoll, 
epoll_wait等待I/O可用的事件。Go中封装的函数为：netpollinit、netpollopen、netpoll。

Go在运行时只会全局调用一次netpollinit函数。上层的Read函数、Write函数底层都会调用netpolloepn函数将对应的Socket放入epoll中监听。

程序可以轮训调用netpoll函数获取准备就绪的Socket。netpoll会调用`epoll_wait`获取epoll中的`eventpoll.rdlist`链表，该链表存储了I/O
就绪的socket列表。接着netpoll取出与该socket绑定的上下文信息，恢复堵塞协程的运行。

netpoll的运行时机有下面两个：

- 系统监控定时检测。Go语言在初始化时会启动一个特殊的线程来执行系统监控任务sysmon。系统监控任务在一个独立的线程上运行，不用绑定逻辑处理器P。系统监控没10ms会检测是否有准备就绪的网络协程，若有，就放到全局队列中。
- 在调度器决定下一个要执行的协程时，如果局部运行队列和全局运行队列都找不到可用协程时，调度器就会获取准备就绪的网络协程。

netpoll处理socket时使用的是非阻塞模式，这也就意味着Go网络模型不会将阻塞陷入到操作系统调用中去。